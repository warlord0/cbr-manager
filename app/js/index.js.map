{"version":3,"sources":["index.coffee"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["'use strict'\r\n\r\nROOT = '/'\r\n\r\n{remote} = require 'electron'\r\napp = remote.app\r\npkg = require '../package.json'\r\nconfigStore = require 'configstore'\r\ncfg = new configStore(pkg.name)\r\nxdgBaseDir = require 'xdg-basedir'\r\npath = require 'path'\r\ncovercache = null\r\n\r\n$ -> # jQuery on ready\r\n    $('#tree').fancytree\r\n        selectMode: 1\r\n        source: (e, data) ->\r\n            nodes = getDir(ROOT)\r\n        lazyLoad: (e, data) ->\r\n            dfd = $.Deferred() # Use a promise to lazyload\r\n            fs = require('fs')\r\n            path = require('path')\r\n            nodepath = data.node.key\r\n            nodes = []\r\n            data.result = dfd.promise()\r\n\r\n            fs.readdir nodepath, (err, files) ->\r\n                if err\r\n                    dfd.resolve []\r\n                    console.error err\r\n                files.map (file) ->\r\n                    file\r\n                .filter (file) -> # We only want directories\r\n                    try\r\n                        fs.statSync(path.join(nodepath, file)).isDirectory()\r\n                    catch err\r\n                        console.error err\r\n                        false\r\n                .forEach (file) ->\r\n                    nodes.push # Build the tree nodes\r\n                        title: file\r\n                        expanded: false\r\n                        folder: true\r\n                        lazy: true\r\n                        key: path.join nodepath, file\r\n                    return\r\n                dfd.resolve nodes # Resolve the promise\r\n                return\r\n            return\r\n\r\n        toggleEffect:\r\n            effect: 'drop'\r\n            options:\r\n                direction: 'left'\r\n            duration: 400\r\n\r\n        beforeActivate: (e, data) ->\r\n            # Clear all the existing covers, ready for the new\r\n            $('#innertube').children().remove()\r\n            return\r\n\r\n        activate: (e, data) ->\r\n            # Get the wallpaper and covers of the new directory\r\n            p = data.node.key\r\n            setWallpaper p\r\n            loadCovers p\r\n            return\r\n\r\n        init: (e, data) ->\r\n            ## selectNode 'c:\\\\mnt\\\\media\\\\incoming\\\\mirc'\r\n            return\r\n\r\n    $ '#splitter'\r\n        .width '100%'\r\n        .height '100%'\r\n        .split\r\n            orientation:'vertical'\r\n            limit:200\r\n            position: cfg.get('browser').split\r\n\r\n    $ window\r\n        .on 'unload', (e) -> # Save the split position to the config\r\n            cfgBrowser = cfg.get 'browser'\r\n            cfgBrowser.split = $('#leftSplit').css 'width'\r\n            cfg.set 'browser', cfgBrowser\r\n            return\r\n\r\n    $ window\r\n        .on 'resize', (e) -> # Make sure the splitter div stays the full window height\r\n            $ '#splitter'\r\n                .height '100%'\r\n\r\n    covercache = cfg.get('covercache') ? path.join xdgBaseDir.data, 'covercache'\r\n    cfg.set\r\n        covercache: covercache\r\n\r\n    return\r\n\r\n# Find and select/activate the specified node\r\n# @param [string] p = path of the node (key). Should match the OS path.\r\nselectNode = (p) ->\r\n    os = require 'os'\r\n    branches = p.split path.sep\r\n\r\n    if os.platform() is 'win32'\r\n        branches[0] += path.sep # Handle the drives because it's windows\r\n\r\n    activeNode = $('#tree').fancytree('getTree').activateKey branches.shift()\r\n    selectChild activeNode, branches\r\n\r\n    return\r\n\r\n# Select and make active the specified node and iterate through\r\n# the specified braches until they are exhausted.\r\n# Used by selectNode(p) to lazyLoad the tree down through the\r\n# specified branches.\r\n# @param [fancyTreeNode] activeNode = the current node\r\n# @param [string[]] branches = the remaining relative paths to\r\n#        expand along\r\nselectChild = (activeNode, branches) ->\r\n    activeNode.setExpanded true\r\n        .then ->\r\n            if activeNode = $('#tree').fancytree.activateKey path.join activeNode.key, branches.shift()\r\n                if branches.length > 0\r\n                    selectChild activeNode, branches\r\n                    return\r\n    return\r\n\r\n# If this is a windows systems get an array of drive letters\r\n# Best way to do whis seems to be cal la shell 'wmic'\r\n# @return string[] drives = active windows drive letters\r\ngetWindowsDrives = ->\r\n    os = require 'os'\r\n    childProcess = require 'child_process'\r\n    tableParser = require 'table-parser'\r\n\r\n    if os.platform() == 'win32'\r\n        stdout = childProcess.execSync 'wmic logicaldisk get caption'\r\n        drives = tableParser.parse(stdout.toString()).map (caption) ->\r\n            caption.Caption[0]\r\n\r\n    drives\r\n\r\n# One time synchronous process to populate the first level ot the tree\r\n# @param [string] p = path to begin the tree from, usually ROOT\r\n# @return [fancyTreeNode[]] nodes = nodes to put on the tree\r\ngetDir = (p) ->\r\n    fs = require 'fs'\r\n    os = require 'os'\r\n    nodes = []\r\n\r\n    # Set the initial nodes as drive letters if windows\r\n    if p is ROOT and os.platform() is 'win32'\r\n        drives = getWindowsDrives()\r\n        for drive in drives\r\n            nodes.push\r\n                title: drive + path.sep\r\n                expanded: false\r\n                folder: true\r\n                lazy: true\r\n                key: drive + path.sep\r\n    else\r\n        files = fs.readdirSync p\r\n        for file in files\r\n            try\r\n                if not fs.statSync(path.join(p, file)).isFile()\r\n                    nodes.push\r\n                        title: file\r\n                        expanded: false\r\n                        folder: true\r\n                        lazy: true\r\n                        key: path.join p, file\r\n            catch error\r\n                console.error error\r\n    return nodes\r\n\r\n# Use an events emitter to asyncronously deal with 'cover' events\r\nevents = require 'events'\r\neventEmitter = new events.EventEmitter()\r\n\r\n# We have a new cover so put it into the #innertube\r\neventEmitter.on 'cover', (arg) ->\r\n    nativeImage = require('electron').nativeImage\r\n    $innertube = $('#innertube')\r\n    id = 'id' + (new Date()).getTime() # Random ID\r\n\r\n    $innertube.append '<div class=\"poster hvr-grow\" data-id=\"' + encodeURI(arg[0]) + '\" id=\"' + id + '\"\"><div class=\"img\"><img class=\"cover\" id=\"' + path.basename(arg[1]) + '\" src=\"' + arg[1] + '\"><p class=\"caption\">' + path.basename(arg[0], path.extname(arg[1])) + '</p></div>'\r\n    tinysort $('div.poster'),\r\n        attr: 'data-id' # Sort the content by data-id. TODO: probably use a better index\r\n\r\n    # Use IPC to tell main.js to launch a reader for the selected document\r\n    $('#' + id).on 'dblclick', (e) ->\r\n        launchReaderIpc decodeURI($(this).attr('data-id')).replace(/\\\\/g, '\\/')\r\n        return\r\n\r\n    return\r\n\r\n# Make #innertube sortable by dragging stuff around\r\n# TODO: Remeber the order? Is this necessary?\r\n$('#innertube').sortable\r\n    revert: true\r\n\r\n# Set the wallpaper/background-image of the cover view\r\n# Will look for a file called folder.jpg or .png to use\r\n# @param [string] p = full path of the folder\r\nsetWallpaper = (p) ->\r\n    fs = require 'fs'\r\n    wallpapers = ['folder.jpg', 'folder.png']\r\n    for wallpaper in wallpapers\r\n        file = path.join(p, wallpaper)\r\n        try\r\n            fs.accessSync file\r\n            $('#wallpaper') # Set the wallpaper and make it transparent\r\n                .css('background-image', 'url(\"file:///' + file.replace(/\\\\/g, '/') + '\")')\r\n                .css('background-size', '100% auto')\r\n                .css('opacity', '0.33')\r\n        catch error\r\n            $('#wallpaper') # Return to the default wallpaper\r\n                .css('background-image', 'url(\"images/superhero-icon.png\")')\r\n                .css('background-size', 'auto')\r\n                .css('opacity', '1.0')\r\n\r\n        break # We found one, no need to look for more\r\n\r\n    return\r\n\r\n# Load the covers for the selected path\r\n# @param [string] p = full path to find the covers for\r\nloadCovers = (p) ->\r\n    fs = require 'fs'\r\n    try\r\n        fs.readdir p, (err, files) ->\r\n            if err\r\n                console.error err\r\n                return\r\n            else\r\n                files.sort().forEach (file, i) ->\r\n                    switch path.extname file\r\n                        when '.cbr', '.cbz', '.cb7'\r\n                            getCover path.join(p, file)\r\n                            return\r\n                    return\r\n    catch error\r\n        console.error error\r\n        return\r\n\r\n    return\r\n\r\n# Read the cover from the covercache or get it an put it in the cache\r\n# Files are store in the covercahce using an MD5 hash of the filename\r\n# @param [string] cbrFile = full path to the selected file\r\n# @return triggers an emit 'cover' event\r\ngetCover = (cbrFile) ->\r\n    try\r\n\r\n        fs = require 'fs'\r\n        crypto = require 'crypto'\r\n        nativeImage = require('electron').nativeImage\r\n        filehash = crypto.createHash('md5').update(path.basename(cbrFile)).digest('hex')\r\n        coverImg = nativeImage.createFromPath(path.join(covercache, filehash.substring(0, 2), filehash + '.png'))\r\n\r\n        if not coverImg.isEmpty() # We found a cover in the cache so use it\r\n            #console.log path.join('covercache', filehash.substring(0, 2), filehash + '.png')\r\n            eventEmitter.emit 'cover', [cbrFile, path.join(covercache, filehash.substring(0, 2), filehash + '.png')]\r\n            return\r\n        else\r\n            # Extract the first page from the document and store it in the covercache\r\n            switch path.extname(cbrFile)\r\n                when '.cbr'\r\n                    unrar = require 'unrar'\r\n                    cbr = new unrar(cbrFile)\r\n                    tmp = require 'tmp'\r\n                    tmpDir = tmp.dir\r\n                        prefix: 'cbr_'\r\n                        unsafeCleanup: true\r\n                        dir: app.getPath 'temp'\r\n                    , _tempDirCreated = (err, tmpPath, cleanupCallback) ->\r\n                        cbr.list (err, entries) ->\r\n                            entries.sort (a, b) ->\r\n                                if path.basename(a.name) < path.basename(b.name)\r\n                                    -1\r\n                                else\r\n                                    1\r\n                            # Strip any non-image files from the beginning of the array\r\n                            while path.extname(entries[0].name) is '' or '.jpg.jpeg.gif.png'.indexOf(path.extname(entries[0].name)) is -1\r\n                                entries.shift()\r\n                            stream = cbr.stream entries[0].name # This is the file we want to extract\r\n                            stream.on 'error', (err) ->\r\n                                console.error err\r\n                                return\r\n                            stream.on 'end', -> # Now we've read the file make it into a cover\r\n                                makeCover cbrFile, filehash, path.join(tmpPath, path.basename(entries[0].name))\r\n                                return\r\n                            # Create a temp file to write the cover into\r\n                            writable = fs.createWriteStream path.join(tmpPath, path.basename(entries[0].name))\r\n                            writable.on 'close', -> # Tidy up the temporary folder\r\n                                cleanupCallback()\r\n                                return\r\n                            stream.pipe writable # Write the compressed file into the temp file and leave the rest to the event handlers\r\n\r\n                            return\r\n\r\n                        return\r\n                when '.cbz', '.cb7'\r\n                    n7z = require 'node-7z'\r\n                    cbr = new n7z\r\n                    imageFiles = []\r\n                    cbr.list cbrFile\r\n                        .progress (compressedFiles) ->\r\n                            # Gather the list of contained files\r\n                            imageFiles = imageFiles.concat compressedFiles\r\n                            return\r\n                        .then (spec) ->\r\n                            tmp = require 'tmp'\r\n                            tmpDir = tmp.dir\r\n                                prefix: 'cbz_'\r\n                                unsafeCleanup: true\r\n                                dir: app.getPath 'temp'\r\n                            , _tempDirCreated = (err, tmpPath, cleanupCallback) ->\r\n                                if err\r\n                                    console.error err\r\n                                    return\r\n                                else\r\n                                    extractedFiles = [] # Create the array to populate with what we extract\r\n                                    if imageFiles.length > 0\r\n                                        imageFiles.sort (a, b) ->\r\n                                            if path.basename(a.name) < path.basename(b.name)\r\n                                                -1\r\n                                            else\r\n                                                1\r\n                                        # Strip the non-image files from the beginning of the array\r\n                                        while path.extname(imageFiles[0].name) is '' or '.jpg.jpeg.gif.png'.indexOf(path.extname(imageFiles[0].name)) is -1\r\n                                            imageFiles.shift()\r\n                                        cbr.extract cbrFile, tmpPath,\r\n                                            wildcards: imageFiles[0].name # Extract only the first image file in our array\r\n                                        .progress (files) ->\r\n                                            extractedFiles = extractedFiles.concat(files) # Update what we extracted, should only be one file\r\n                                            return\r\n                                        .then ->\r\n                                            if extractedFiles[0]? # If we got an image make it into a cover\r\n                                                # 7-zip seems to leave trailing carriage returns. I guess it was tested mainly in *nix\r\n                                                makeCover cbrFile, filehash, path.join(tmpPath, path.basename(extractedFiles[0])).replace('\\r', '')\r\n                                            else\r\n                                                console.error 'Unable to extract files from ' + cbrFile\r\n                                            cleanupCallback() # Tidy up the temporay folder\r\n                                            return\r\n                                        return\r\n                                    else\r\n                                        eventEmitter.emit 'cover', [cbrFile, path.join('images', 'nocover.png')]\r\n                                        return\r\n                            return\r\n                        .catch (err) ->\r\n                            console.error 'Can\\'t handle file ' + cbrFile\r\n                            eventEmitter.emit 'cover', [cbrFile, path.join('images', 'nocover.png')]\r\n                            return\r\n        return\r\n    catch err\r\n        console.error err\r\n\r\n# Create a cover by resizing the tmpFile as storing it into the covercache\r\n# Then trigger the 'cover' event to show it in the covers browser\r\n# @param [string] cbrFile = full path of the file the cover is for\r\n# @param [string] filehash = MD5 hash of the file name used to put it into the covercache\r\n# @param [string] tmpFile = full path of the tmpFile to read the image from\r\nmakeCover = (cbrFile, filehash, tmpFile) ->\r\n    try\r\n        nativeImage = require('electron').nativeImage\r\n        fs = require 'fs'\r\n        coverImg = nativeImage.createFromPath tmpFile\r\n        buffer = coverImg.resize\r\n            height: 240 # Specify only height and width is auto bassed on aspect ratio\r\n\r\n        if buffer.isEmpty() # Something unexpected means we don't have a cover image\r\n            eventEmitter.emit 'cover', [cbrFile, path.join('images', 'nocover.png')]\r\n        else\r\n            mkdirp = require 'mkdirp' # Make the directory and put the resized image into the covercache\r\n            mkdirp path.join(covercache, filehash.substring(0, 2)), (err) ->\r\n                if err\r\n                    console.error err\r\n                else\r\n                    png = buffer.toPng()\r\n                    fs.writeFile path.join(covercache, filehash.substring(0, 2), filehash + '.png'), png, (err) ->\r\n                        if err\r\n                            console.error err\r\n                        else\r\n                            eventEmitter.emit 'cover', [cbrFile, path.join(covercache, filehash.substring(0, 2), filehash) + '.png']\r\n                return\r\n    catch error\r\n        console.error error\r\n        eventEmitter.emit 'cover', [cbrFile, path.join('images', 'nocover.png')]\r\n    return\r\n\r\n# Use IPC to call main.js and launch the reader\r\n{ipcRenderer} = require 'electron'\r\n\r\nlaunchReaderIpc = (cbrFile) ->\r\n    ipcRenderer.send 'LaunchReader', cbrFile\r\n"]}