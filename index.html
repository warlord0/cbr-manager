<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Comic Book Browser</title>

    <link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="node_modules/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="node_modules/jquery.fancytree/dist/skin-lion/ui.fancytree.min.css">

    <style type="text/css">
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            max-height: 100%;
            font-family: Sans-serif;
            line-height: 1.5em;
            background-color: #000;
        }

        #nav {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            width: 230px;
            /* Width of navigation frame */
            height: 100%;
            /* overflow: hidden; /* Disables scrollbars on the navigation frame. To enable scrollbars, change "hidden" to "scroll" */
            overflow: auto;
            background: #fff;
        }

        #tree {
            width: auto;
            height: 100%;
            top: 0;
            left: 0;
            bottom: 0;
        }

        main {
            position: fixed;
            top: 0;
            left: 230px;
            /* Set this to the width of the navigation frame */
            right: 0;
            bottom: 0;
            overflow: auto;
        }

        #wallpaper {
            content: "";
            top:  0;
            left: 230px;
            bottom: 0;
            right: 0;
            background-image: url(images/superhero-icon.png);
            background-repeat: no-repeat;
            background-position: center center;
            z-index: -1;
            opacity: 1.0;
            position: fixed;
        }

        #innertube {
            margin: 15px;
            /* Provides padding for the content */
        }

        p {
            color: #555;
        }

        nav ul {
            list-style-type: none;
            margin: 0;
            padding: 0;
        }

        nav ul a {
            color: darkgreen;
            text-decoration: none;
        }
        /*IE6 fix*/

        * html body {
            padding: 0 0 0 230px;
            /* Set the last value to the width of the navigation frame */
        }

        * html main {
            height: 100%;
            width: 100%;
        }

        div.poster {
            opacity: 0.67;
            float: left;
            margin-right: 15px;
            margin-bottom: 15px;
            width: 160px;
            height: 300px;
            max-height: 300px;
        }

        div.poster:hover {
            opacity: 1.0;
        }

        div.poster p.caption {
            text-align: center;
            color: silver;
        }

        .img {
            width: 160px;
            overflow: hidden; /* Trim any over width covers */
        }
        .cover {
            zwidth: 160px;
            height: 240px;
        }

        ul.fancytree-container {
            border: none;
        }

        /* Grow */
        .hvr-grow {
          display: inline-block;
          vertical-align: middle;
          -webkit-transform: translateZ(0);
          transform: translateZ(0);
          box-shadow: 0 0 1px rgba(0, 0, 0, 0);
          -webkit-backface-visibility: hidden;
          backface-visibility: hidden;
          -moz-osx-font-smoothing: grayscale;
          -webkit-transition-duration: 0.3s;
          transition-duration: 0.3s;
          -webkit-transition-property: transform;
          transition-property: transform;
        }
        .hvr-grow:hover, .hvr-grow:focus, .hvr-grow:active {
          -webkit-transform: scale(1.1);
          transform: scale(1.1);
        }
    </style>
</head>

<body>
    <div id="wallpaper"></div>
    <main>
        <div id="innertube">
        </div>
    </main>

    <nav id="nav">
        <div id="tree" class="fancytree-colorize-hover fancytree-fade-expander"></div>
    </nav>

    <!-- Insert this line above script imports  -->
    <script>
        if (typeof module === 'object') {
            window.module = module;
            module = undefined;
        }
    </script>

    <script>
        global.jQuery = require('jquery/dist/jquery.min.js');
        global.$ = jQuery;
        var jQueryUI = require('jqueryui'),
            jQueryFancyTree = require('jquery.fancytree/dist/jquery.fancytree-all.js'),
            bootstrap = require('bootstrap'),
            tinysort = require('tinysort/dist/tinysort.js').tinysort;
    </script>

    <script>
        // glyph_opts = {
        //     map: {
        //         doc: "glyphicon glyphicon-file",
        //         docOpen: "glyphicon glyphicon-file",
        //         checkbox: "glyphicon glyphicon-unchecked",
        //         checkboxSelected: "glyphicon glyphicon-check",
        //         checkboxUnknown: "glyphicon glyphicon-share",
        //         dragHelper: "glyphicon glyphicon-play",
        //         dropMarker: "glyphicon glyphicon-arrow-right",
        //         error: "glyphicon glyphicon-warning-sign",
        //         expanderClosed: "glyphicon glyphicon-menu-right",
        //         expanderLazy: "glyphicon glyphicon-plus-sign",
        //         expanderOpen: "glyphicon glyphicon-menu-down",
        //         folder: "glyphicon glyphicon-folder-close",
        //         folderOpen: "glyphicon glyphicon-folder-open",
        //         loading: "glyphicon glyphicon-refresh glyphicon-spin"
        //     }
        // };

        const ROOT = '/';
        $(function() {
            // Initialize Fancytree
            $("#tree").fancytree({
                //extensions: ["wide"],
                //extensions: ["dnd", "edit", "glyph", "wide"],
                //checkbox: true,
                // dnd: {
                //     focusOnClick: true,
                //     dragStart: function(node, data) {
                //         return true;
                //     },
                //     dragEnter: function(node, data) {
                //         return false;
                //     },
                //     dragDrop: function(node, data) {
                //         data.otherNode.copyTo(node, data.hitMode);
                //     }
                // },
                //glyph: glyph_opts,
                selectMode: 1,

                source: (e, data) => {
                    var nodes = GetDir(ROOT);
                    //console.log(nodes);
                    return nodes;
                },
                lazyLoad: function(event, data) {
                    var dfd = $.Deferred(),
                        fs = require('fs'),
                        path = require('path'),
                        nodepath = data.node.key;
                        nodes = [];

                    data.result = dfd.promise(); // Use a promise so we can use readdir asynchronously

                    fs.readdir(nodepath, (err, files) => {
                        if (err) {
                            // throw the error last so we can complete the promise
                            dfd.resolve([]);
                            console.error(err);
                        }
                        // .map an array so we can filter it
                        files.map((file) => {
                            return file;
                        }).filter((file) => {
                            // Make sure it's a folder
                            try {
                                return fs.statSync(path.join(nodepath, file)).isDirectory();
                            } catch (err) {
                                console.error(err);
                                return false;
                            }
                        }).forEach((file) => {
                            // Build array of node objects
                            nodes.push({
                                "title": file,
                                "expanded": false,
                                "folder": true,
                                "lazy": true,
                                "key": path.join(nodepath, file)
                            });
                        });
                        //console.log(nodes);
                        dfd.resolve(nodes);
                    });
                },
                toggleEffect: {
                    effect: "drop",
                    options: {
                        direction: "left"
                    },
                    duration: 400
                },
                // wide: {
                //     iconWidth: "1em", // Adjust this if @fancy-icon-width != "16px"
                //     iconSpacing: "0.5em", // Adjust this if @fancy-icon-spacing != "3px"
                //     levelOfs: "1.5em" // Adjust this if ul padding != "16px"
                // },
                icon: (e, data) => {
                    // if( data.node.isFolder() ) {
                    //   return "glyphicon glyphicon-book";
                    // }
                },
                beforeActivate: (e, data) => {
                    $('#innertube').children().remove();
                },
                activate: (e, data) => {
                    var p = data.node.key;
                    SetWallpaper(p);
                    LoadCovers(p);
                },
                init: (e, data) => {
                    // Tree is loaded
                    //SelectNode('C:\\mnt\\media\\comics\\archive\\Dark Horse\\BPRD');
                }
            });

        });

        /**
         * Select and Activate a node in the tree.
         * The node may be lazy laoaded so we need to expand it and ensure the lazy loads get laoaded
         *
         * @param string p - a unique node key (or file system path)
         */
        function SelectNode(p) {
            const path = require('path'),
                os = require('os');

            var branches = p.split(path.sep);

            if (os.platform() == 'win32') { // The drive letter needs a trailing \ added in Windows
                branches[0] += path.sep;
            }

            var activeNode = $("#tree").fancytree("getTree").activateKey(branches.shift());
            SelectChild(activeNode, branches);

        }

        /**
         * Because .setExpanded is an async $.Promise we have to ask it to call the next child once it
         * has populated the current node. So it must call itself until exhausted.
         *
         * @param FancyTreeNode activeNode the currently selected and active node
         * @param [] branches the remainder, or relative path left to fetch
         */
        function SelectChild(activeNode, branches) {
            activeNode.setExpanded(true)
                .then(() => {
                    if (activeNode = $("#tree").fancytree("getTree").activateKey(path.join(activeNode.key, branches.shift()))) {
                        if (branches.length > 0) {
                            SelectChild(activeNode, branches);
                        }
                    }
                });
        }

        /**
         * Get the specified directory contents synchronously
         * Done as readdirSync as this is a one time deal at first load
         * Future calls are made as a lazyload asynchronously
         *
         * @param string p path to retrieve
         */
        function GetDir(p) {
            var fs = require('fs'),
                path = require('path'),
                os = require('os');

            let nodes = [];

            // Fetch the root directory OR drive letters if on Windows
            if (p == ROOT && os.platform() == 'win32') {
                var drives = GetWindowsDrives();
                console.log(drives);
                for (i = 0; i < drives.length; i++) {
                    nodes.push({
                        "title": drives[i] + path.sep,
                        "expanded": false,
                        "folder": true,
                        "lazy": true,
                        "key": drives[i] + path.sep
                    });
                }
            } else {
                var files = fs.readdirSync(p);
                //console.log(files);
                for (i = 0; i < files.length; i++) {
                    try {
                        if (!fs.statSync(path.join(p, files[i])).isFile()) {
                            //console.log({"title": file, "expanded": false, "folder": true, "lazy": true});
                            nodes.push({
                                "title": files[i],
                                "expanded": false,
                                "folder": true,
                                "lazy": true,
                                "key": path.join(p, files[i])
                            });
                        } else {
                            /* In this instance we only want folders */
                            //nodes.push({"title": files[i]});
                        }
                    } catch (err) {}
                }
            }
            return nodes;
        }

        /**
         * If we're running on Windows we'll need to start by getting the drive letters
         * For this we'll have to call out a child process exec
         *
         * @return array drives
         */
        function GetWindowsDrives() {
            const os = require('os'),
                childProcess = require('child_process'),
                tableParser = require('table-parser');

            var drives = [];
            if (os.platform() == 'win32') {
                const stdout = childProcess.execSync('wmic logicaldisk get caption');
                //console.log(stdout);
                drives = tableParser.parse(stdout.toString()).map((caption) => {
                    console.log(caption.Caption[0]);
                    return caption.Caption[0];
                });
            }
            return drives;
        }

        const events = require('events');
        const eventEmitter = new events.EventEmitter();

        eventEmitter.on('cover', (arg) => {
            var nativeImage = require('electron').nativeImage,
                path = require('path'),
                $innertube = $('div#innertube'),
                id = 'id' + (new Date()).getTime();

            $innertube.append(
                '<div class="poster hvr-grow" data-id="' + encodeURI(arg[0]) + '" id="' + id + '""><div class="img"><img class="cover" id="' + path.basename(arg[1]) + '" src="' + arg[1] +
                '"><p class="caption">' + path.basename(arg[0], path.extname(arg[1])) + '</p></div>'
            );
            tinysort($('div.poster'), {
                attr: 'id'
            }); // Sort the divs by their ID so the files appear in order
            $('#' + id).on('dblclick', function() { // Attache double click event
                LaunchReaderIpc(decodeURI($(this).attr('data-id')).replace(/\\/g, '\/'));
            })
        });

        $('#innertube').sortable({ // Use the sortable plugin so files can be dragged and rearranged
            revert: true
        });

        /**
         * Set the background-mage of the cover brwwser to either folder.jpg or folder.png if they exist in the chosen path
         *
         * @param string p = path of the wallpaper iamge to look for
         */
        function SetWallpaper(p) {
            const fs = require('fs'),
                path = require('path');

            var wallpapers = ['folder.jpg', 'folder.png']; // Look for these files
            for (var i = 0; i < wallpapers.length; i++) {
                var file = path.join(p, wallpapers[i]);
                try {
                    fs.accessSync(file); // This will throw an error if it doesn't exist
                    $('#wallpaper').css('background-image', 'url("file:///' + file.replace(/\\/g,'/') + '")')
                        .css('background-size', '100% auto')
                        .css('opacity', '0.33');
                    break; // OK we found one let's stop looking for more
                } catch (err) {
                    $('#wallpaper').css('background-image', 'url(images/superhero-icon.png)')
                        .css('background-size', 'auto')
                        .css('opacity', '1.0'); // Set it to the defaul if nothing found
                    //console.error(err); // No need to throw an erro we expected this
                }
            }
        }

        /**
         * Load the cover images from the specified path
         *
         * @param p path to retrieve images for
         */
        function LoadCovers(p) {
            const fs = require('fs'),
                path = require('path');
            var files = [];

            try {
                fs.readdir(p, (err, data) => {
                    if (err) {
                        console.error(err);
                    } else {
                        data.sort().forEach(function(file) {
                            switch (path.extname(file)) {
                                case '.cbr':
                                case '.cbz':
                                case '.cb7':
                                    GetCover(path.join(p, file));
                                    break;
                            }
                        });
                    }
                });
            } catch (err) {
                console.error(err);
            }
        }

        const path = require('path');

        /*
         * Get the specified cover from the file
         *
         * @param string file - archive to get the cover from
         *
         * @return emits a 'cover' event with a nativeImage and path to the cover
         */
        function GetCover(cbrFile) {
            var fs = require('fs'),
                path = require('path'),
                crypto = require('crypto'),
                filehash = crypto.createHash('md5').update(path.basename(cbrFile)).digest('hex'),
                nativeImage = require('electron').nativeImage;

            var coverImg = nativeImage.createFromPath(path.join(__dirname, 'covercache', filehash.substring(0, 2), filehash + ".png"));
            if (!coverImg.isEmpty()) {
                eventEmitter.emit('cover', [cbrFile, path.join('covercache', filehash.substring(0, 2), filehash + ".png")]); // Trigger the cover event
                //console.log('cached image ' + cbrFile)
            } else {
                switch (path.extname(cbrFile)) {
                    case '.cbz':
                        //case '.zip':
                    case '.cbr':
                    case '.cb7':
                        //case '.rar':
                        var n7z = require('node-7z'), // WARNING: Node7z requires "Extracting  " message in stdout use 7za renamed 7z from v^9.38 - NOT v^15.
                            imageFiles = [], // The array of compressed files
                            cbr = new n7z();

                        cbr.list(cbrFile) // First lets get the first image file from the compressed file
                            .progress(function(compressedFiles) {
                                compressedFiles.forEach(function(compressedFile) { // Populate the array of compressed files
                                    if (path.extname(compressedFile.name) != '' && '.jpg.jpeg.gif.png'.indexOf(path.extname(compressedFile.name)) != -1) {
                                        imageFiles.push(compressedFile.name);
                                    }
                                });
                            })
                            .then(function(spec) { // Now we have finished the list extract the imageFiles
                                var tmp = require('tmp'); // Create a unique temp dir because we don't want clashing async filenames
                                tmpDir = tmp.dir({
                                    prefix: 'tmp_',
                                    //dir: path.join(__dirname, 'temp'), // Put them somewhere other than system temp
                                    unsafeCleanup: true
                                }, function _tempDirCreated(err, tmpPath, cleanupCallback) {
                                    if (err) throw err;
                                    if (imageFiles.length > 0) {
                                        imageFiles.sort(); // Sort the file array as they may not be stored in order
                                        //console.log(cbrFile, imageFiles);
                                        var extractedFiles = [];
                                        cbr.extract(cbrFile, tmpPath, {
                                                    wildcards: imageFiles[0]
                                                } // we only want the first file
                                            )
                                            .progress((files) => {
                                                extractedFiles = extractedFiles.concat(files);
                                            })
                                            .then(() => {
                                                try {
                                                    // Use createFromPath as it's synchronous if we use an async read like readFile we move out of the thread and all
                                                    // kinds of weird stuff happens as variables get updated by other async processes
                                                    var coverImg = nativeImage.createFromPath(path.join(tmpPath, extractedFiles[0].replace('\r', ''))), // Load the image
                                                        buffer = coverImg.resize({
                                                            height: 240
                                                        });
                                                    //console.log('here!', cbrFile, path.join(tmpPath, extractedFiles[0].replace('\r', '')), coverImg.isEmpty(), buffer.isEmpty());
                                                    if (buffer.isEmpty()) { // TODO: Something not right here... animated gif?
                                                        eventEmitter.emit('cover', [cbrFile, path.join('images', 'nocover.png')]); // Trigger the cover event
                                                    } else {
                                                        //console.log('Caching', cbrFile);
                                                        var mkdirp = require('mkdirp');

                                                        mkdirp(path.join(__dirname, 'covercache', filehash.substring(0, 2)), function(err) {
                                                            if (err) {
                                                                console.error(err);
                                                            } else {
                                                                // Save the buffer to a file as a png (.toPng) format
                                                                var png = buffer.toPng();
                                                                fs.writeFile(path.join(__dirname, 'covercache', filehash.substring(0, 2), filehash + '.png'), png,
                                                                    (err) => {
                                                                        if (err) {
                                                                            console.error(err);
                                                                        } else {
                                                                            eventEmitter.emit('cover', [cbrFile, path.join('covercache', filehash.substring(0, 2), filehash) + '.png']); // Trigger the cover event
                                                                        }
                                                                    }
                                                                )
                                                            }
                                                        });
                                                    }
                                                } catch (err) {
                                                    console.error(err);
                                                    eventEmitter.emit('cover', [cbrFile, path.join('images', 'nocover.png')]); // Trigger the cover event
                                                } finally {
                                                    cleanupCallback();
                                                }
                                            });
                                    } else {
                                        eventEmitter.emit('cover', [cbrFile, path.join('images', 'nocover.png')]); // Trigger the cover event
                                    }
                                });
                            })
                            .catch(function(err) {
                                console.error(err);
                            });
                        break;
                }
            }
        }

        function CacheImage(file, buffer) {
            // Create the folder if it doesn't exist
            var fs = require('fs'),
                mkdirp = require('mkdirp'),
                crypto = require('crypto'),
                filehash = crypto.createHash('md5').update(path.basename(file)).digest('hex');

            mkdirp(path.join(__dirname, 'covercache', filehash.substring(0, 2)), function(err) {
                if (err) {
                    console.error(err);
                } else {
                    // Save the buffer to a file as a png (.toPng) format
                    var png = buffer.toPng();
                    fs.writeFile(path.join(__dirname, 'covercache', filehash.substring(0, 2), filehash + '.png'), png,
                        function(err) {
                            if (err) {
                                console.error(err);
                            } else {
                                cleanupCallback(); // Now the files written cleanup the temp dir
                                //console.log('non-cached image ' + file)
                                eventEmitter.emit('cover', [file, path.join('covercache', filehash.substring(0, 2), filehash) + '.png']); // Trigger the cover event
                            }
                        }
                    )
                }
            });
        }

        const {ipcRenderer} = require('electron');

        function LaunchReaderIpc(cbr) {
            ipcRenderer.send('LaunchReader', cbr);
        }

    </script>

    <!-- Insert this line after script imports -->
    <script>
        if (window.module) module = window.module;
    </script>

</body>

</html>
